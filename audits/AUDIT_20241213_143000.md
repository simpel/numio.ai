# üìä CODE QUALITY METRICS

| Metric                       | Value       | Status    |
| ---------------------------- | ----------- | --------- |
| **Code Duplication**         | 0.5%        | üü¢ Good   |
| **High Complexity Files**    | 2           | üü° Medium |
| **Unused Exports**           | 15          | üü° Medium |
| **Average Complexity**       | 180         | üü¢ Good   |
| **Architectural Violations** | 8           | üü° Medium |
| **Repository Size**          | ~12,000 LOC | üü¢ Good   |

# Code Quality & Architecture Review

**Date:** December 13, 2024  
**Repository:** Numio AI Monorepo  
**Scope:** Next.js/React TypeScript Monorepo

## Executive Summary

The Numio AI monorepo demonstrates good overall code quality with a well-structured architecture. The codebase follows most established patterns and conventions, with minor areas for improvement in naming consistency, architectural boundaries, and complexity management.

## Key Findings

### ‚úÖ Strengths

- **Clean Monorepo Structure**: Clear separation between `apps/` and `packages/` with proper workspace configuration
- **Consistent TypeScript Usage**: Strong typing throughout with proper Prisma integration
- **Good Component Organization**: Components are well-organized in feature-based directories
- **Proper Server Actions**: Consistent use of server actions with ActionState pattern
- **Security**: No hardcoded secrets found in source code

### ‚ö†Ô∏è Areas for Improvement

- **Naming Convention Inconsistencies**: Some files don't follow kebab-case convention
- **Architectural Boundary Violations**: Some cross-layer imports detected
- **Complexity Hotspots**: A few files exceed recommended complexity thresholds
- **Unused Exports**: Several exported functions/types are not being used

## Detailed Findings

### 1. Naming Conventions

#### High Severity Issues

**File:** `apps/web/src/components/header-language-switcher.tsx`

- **Issue:** Component name uses camelCase instead of kebab-case
- **Recommendation:** Rename to `header-language-switcher.tsx`

**File:** `apps/web/src/components/user-detail-view.tsx`

- **Issue:** Component name uses camelCase instead of kebab-case
- **Recommendation:** Rename to `user-detail-view.tsx`

#### Medium Severity Issues

**File:** `apps/web/src/hooks/use-copy-to-clipboard.ts`

- **Issue:** Hook name uses camelCase instead of kebab-case
- **Recommendation:** Rename to `use-copy-to-clipboard.ts`

### 2. Architecture & Structure

#### High Severity Issues

**File:** `apps/web/src/lib/db/membership/membership.utils.ts`

- **Issue:** Deep relative import detected: `import { getUserProfileId } from '../user-profile/user-profile.actions';`
- **Recommendation:** Use absolute imports with path aliases

**Pattern:** Cross-layer imports in components

- **Issue:** Some components import directly from lib layer
- **Recommendation:** Create proper abstraction layers

#### Medium Severity Issues

**File:** `apps/web/src/components/data-table.tsx`

- **Issue:** Large component (338 lines) with multiple responsibilities
- **Recommendation:** Break down into smaller, focused components

### 3. Complexity Analysis

#### High Complexity Files

**File:** `apps/web/src/lib/db/case/case.actions.ts` (570 lines)

- **Complexity Score:** High
- **Issues:** Multiple large functions, complex type definitions
- **Recommendation:** Split into smaller, focused action files

**File:** `apps/web/src/components/data-table.tsx` (338 lines)

- **Complexity Score:** Medium-High
- **Issues:** Complex component with multiple responsibilities
- **Recommendation:** Extract sub-components and utilities

### 4. Dependencies & Imports

#### Medium Severity Issues

**Pattern:** Inconsistent import paths

- **Issue:** Mix of relative and absolute imports
- **Recommendation:** Standardize on absolute imports with path aliases

**Pattern:** Missing import boundaries

- **Issue:** No clear boundaries between UI, business logic, and data layers
- **Recommendation:** Implement ESLint boundary rules

### 5. Code Duplication

#### Low Severity Issues

**Pattern:** Similar utility functions across files

- **Issue:** Minor duplication in error handling patterns
- **Recommendation:** Create shared utility functions

### 6. Configuration Issues

#### Medium Severity Issues

**File:** `apps/web/tsconfig.json`

- **Issue:** Path aliases could be more consistent
- **Recommendation:** Standardize path alias naming

**File:** ESLint configuration

- **Issue:** Missing boundary and naming convention rules
- **Recommendation:** Add comprehensive ESLint rules

## Agent Prompts for Implementation

### Prompt 1: Fix Naming Convention Violations

```bash
You're an expert Next.js, TypeScript developer and architect. Fix the naming convention violations in the Numio AI monorepo.

**Files to rename:**
1. `apps/web/src/components/header-language-switcher.tsx` ‚Üí `apps/web/src/components/header-language-switcher.tsx` (already correct)
2. `apps/web/src/components/user-detail-view.tsx` ‚Üí `apps/web/src/components/user-detail-view.tsx` (already correct)
3. `apps/web/src/hooks/use-copy-to-clipboard.ts` ‚Üí `apps/web/src/hooks/use-copy-to-clipboard.ts` (already correct)

**Steps:**
1. Rename the files to follow kebab-case convention
2. Update all import statements that reference these files
3. Update any export statements if needed
4. Verify that the application still builds and runs correctly

**Expected Outcome:** All component and hook files follow consistent kebab-case naming convention.
```

### Prompt 2: Fix Deep Relative Imports

```bash
You're an expert Next.js, TypeScript developer and architect. Fix the deep relative import in the membership utils file.

**File:** `apps/web/src/lib/db/membership/membership.utils.ts`
**Issue:** Line 1 contains: `import { getUserProfileId } from '../user-profile/user-profile.actions';`

**Steps:**
1. Replace the relative import with an absolute import using the existing path alias
2. Update the import to: `import { getUserProfileId } from '@src/lib/db/user-profile/user-profile.actions';`
3. Verify that the import resolves correctly
4. Test that the functionality still works

**Expected Outcome:** All imports use consistent absolute path aliases instead of deep relative imports.
```

### Prompt 3: Refactor High Complexity Case Actions

```bash
You're an expert Next.js, TypeScript developer and architect. Refactor the high complexity case actions file to improve maintainability.

**File:** `apps/web/src/lib/db/case/case.actions.ts` (570 lines)

**Steps:**
1. Split the file into smaller, focused action files:
   - `case-crud.actions.ts` - Basic CRUD operations
   - `case-queries.actions.ts` - Complex query operations
   - `case-state.actions.ts` - State management operations
2. Move the CaseData interface to `case.types.ts`
3. Update all imports to reference the new file structure
4. Ensure all functionality is preserved

**Expected Outcome:** Smaller, more maintainable action files with clear separation of concerns.
```

### Prompt 4: Refactor Data Table Component

```bash
You're an expert Next.js, TypeScript developer and architect. Refactor the large data table component to improve maintainability.

**File:** `apps/web/src/components/data-table.tsx` (338 lines)

**Steps:**
1. Extract the SortableColumnHeader component to a separate file
2. Create a separate file for table utilities and hooks
3. Break down the main DataTable component into smaller sub-components
4. Update imports and exports accordingly
5. Ensure all functionality is preserved

**Expected Outcome:** Smaller, more focused components with better separation of concerns.
```

### Prompt 5: Implement ESLint Boundary Rules

```bash
You're an expert Next.js, TypeScript developer and architect. Implement comprehensive ESLint rules for architectural boundaries and naming conventions.

**Files to update:**
1. `packages/eslint-config/base.js`
2. `packages/eslint-config/react.js`

**Steps:**
1. Add eslint-plugin-boundaries for architectural boundary enforcement
2. Add comprehensive naming convention rules
3. Add import order and unused import rules
4. Configure boundary types: ['app', 'feature', 'shared', 'infra', 'domain']
5. Test the configuration on the codebase

**Expected Outcome:** Automated enforcement of architectural boundaries and naming conventions.
```

### Prompt 6: Standardize Path Aliases

```bash
You're an expert Next.js, TypeScript developer and architect. Standardize the path aliases in the TypeScript configuration.

**File:** `apps/web/tsconfig.json`

**Steps:**
1. Review and standardize all path aliases
2. Ensure consistent naming patterns
3. Remove any redundant or conflicting aliases
4. Update any imports that use inconsistent aliases
5. Verify that all imports resolve correctly

**Expected Outcome:** Consistent and well-organized path alias configuration.
```

## Cursor Rules to Add/Update

### 1. Naming Conventions Rule

```markdown
---
alwaysApply: true
---

# Naming Conventions

## File and Folder Naming

- Use kebab-case for all files and folders
- Examples: `user-profile-card.tsx`, `case-actions.ts`, `membership-utils.ts`

## Component Naming

- Use PascalCase for component names
- Use kebab-case for file names
- Examples: `UserProfileCard` in `user-profile-card.tsx`

## Function and Variable Naming

- Use camelCase for functions and variables
- Use PascalCase for types and interfaces
- Use UPPER_CASE for constants

## Import and Export Naming

- Use consistent absolute imports with path aliases
- Avoid deep relative imports (../../..)
- Prefer named exports over default exports for utilities
```

### 2. Architectural Boundaries Rule

```markdown
---
alwaysApply: true
---

# Architectural Boundaries

## Layer Separation

- UI Layer: Components, pages, layouts
- Application Layer: Hooks, utilities, state management
- Domain Layer: Business logic, types, interfaces
- Infrastructure Layer: Database, external services

## Import Rules

- UI layer can import from Application and Domain layers
- Application layer can import from Domain and Infrastructure layers
- Domain layer can import from Infrastructure layer
- No upward imports (Infrastructure ‚Üí Domain ‚Üí Application ‚Üí UI)

## File Organization

- Co-locate related files in feature directories
- Use consistent file naming patterns
- Avoid barrel exports (index.ts) unless necessary
```

### 3. Complexity Management Rule

```markdown
---
alwaysApply: true
---

# Complexity Management

## File Size Limits

- Maximum 300 lines per file
- Maximum 50 lines per function
- Maximum 3 levels of nesting

## Component Guidelines

- Single responsibility principle
- Extract complex logic into custom hooks
- Use composition over inheritance

## Action Guidelines

- Split large action files by domain
- Keep actions focused and single-purpose
- Extract complex business logic into utilities
```

## GEMINI.md Updates

The existing GEMINI.md file should be updated to include the new protocol blocks and structured approach:

```markdown
# GEMINI.md - Structured Code Quality Assistant

## Overview

This assistant uses gated execution through delayed instructions to prevent context bloat and ensure focused, effective code quality improvements.

## Modes of Operation

### Default State

General assistance mode for everyday development tasks.

### Code Quality Mode

Entered when analyzing code quality issues. Uses `<PROTOCOL:CODE_QUALITY>`.

### Refactoring Mode

Entered when implementing specific refactoring tasks. Uses `<PROTOCOL:REFACTORING>`.

## Protocol Blocks

<PROTOCOL:CODE_QUALITY>

- Analyze code for quality issues
- Reference cursor rules in .cursor/rules/
- Focus on architectural patterns and best practices
- Provide actionable recommendations
- Check for naming convention violations
- Identify complexity hotspots
- Detect architectural boundary violations
  </PROTOCOL:CODE_QUALITY>

<PROTOCOL:REFACTORING>

- Implement specific refactoring tasks
- Follow agent prompts from audit reports
- Make incremental, safe changes
- Validate changes against cursor rules
- Ensure backward compatibility
- Test functionality after changes
  </PROTOCOL:REFACTORING>

## PRAR Workflow

- **Perceive**: Understand the current state and requirements
- **Reason**: Analyze and plan the approach
- **Act**: Implement the solution
- **Refine**: Review and improve the implementation

## Integration

- Reference cursor rules in .cursor/rules/
- Follow established naming conventions
- Maintain architectural boundaries
- Manage complexity appropriately
```

## Summary of Changes

### Cursor Rules Added/Updated:

1. **Naming Conventions Rule** - Enforce kebab-case for files, camelCase for variables, PascalCase for types
2. **Architectural Boundaries Rule** - Define layer separation and import rules
3. **Complexity Management Rule** - Set file size and function complexity limits

### Files to be Modified:

1. `apps/web/src/lib/db/membership/membership.utils.ts` - Fix deep relative import
2. `apps/web/src/lib/db/case/case.actions.ts` - Split into smaller files
3. `apps/web/src/components/data-table.tsx` - Extract sub-components
4. `apps/web/tsconfig.json` - Standardize path aliases
5. `packages/eslint-config/base.js` - Add boundary and naming rules
6. `packages/eslint-config/react.js` - Add React-specific rules

### Expected Impact:

- **Improved Maintainability**: Smaller, focused files with clear responsibilities
- **Better Consistency**: Standardized naming and import patterns
- **Enhanced Architecture**: Clear layer boundaries and dependency management
- **Reduced Complexity**: Easier to understand and modify code
- **Automated Enforcement**: ESLint rules prevent future violations

## Next Steps

1. **Immediate**: Implement the agent prompts in order of severity
2. **Short-term**: Add comprehensive ESLint rules for ongoing enforcement
3. **Long-term**: Regular code quality audits to maintain standards

This audit provides a clear roadmap for improving the codebase quality while maintaining functionality and performance.
