# Action Patterns

## Server Action Standards

- **NO CLASSES** - Use functions for all CRUD operations
- Implement consistent error handling with ActionState<T>
- Follow CRUD naming pattern: create, read, update, delete
- Use proper TypeScript typing
- Follow naming conventions (Action suffix)
- Group related actions in single files

## CRUD Function Pattern

### Standard CRUD Functions

```typescript
// Create
export async function createEntityAction(
	input: CreateEntityInput
): Promise<ActionState<Entity>> {
	try {
		// Validation
		const validation = validateEntityInput(input);
		if (!validation.isValid) {
			return { isSuccess: false, message: validation.error };
		}

		// Business logic
		const entity = await db.entity.create({ data: input });

		return {
			isSuccess: true,
			message: 'Entity created successfully',
			data: entity,
		};
	} catch (error) {
		console.error('Error creating entity:', error);
		return { isSuccess: false, message: 'Failed to create entity' };
	}
}

// Read (Single)
export async function getEntityByIdAction(
	id: string
): Promise<ActionState<Entity>> {
	try {
		const entity = await db.entity.findUnique({ where: { id } });

		if (!entity) {
			return { isSuccess: false, message: 'Entity not found' };
		}

		return { isSuccess: true, data: entity };
	} catch (error) {
		console.error('Error fetching entity:', error);
		return { isSuccess: false, message: 'Failed to fetch entity' };
	}
}

// Read (Multiple)
export async function getEntitiesAction(
	params: GetEntitiesParams
): Promise<ActionState<Entity[]>> {
	try {
		const entities = await db.entity.findMany({
			where: params.where,
			include: params.include,
			orderBy: params.orderBy,
			take: params.take,
			skip: params.skip,
		});

		return { isSuccess: true, data: entities };
	} catch (error) {
		console.error('Error fetching entities:', error);
		return { isSuccess: false, message: 'Failed to fetch entities' };
	}
}

// Update
export async function updateEntityAction(
	id: string,
	input: UpdateEntityInput
): Promise<ActionState<Entity>> {
	try {
		// Validation
		const validation = validateUpdateEntityInput(input);
		if (!validation.isValid) {
			return { isSuccess: false, message: validation.error };
		}

		// Check if entity exists
		const existing = await db.entity.findUnique({ where: { id } });
		if (!existing) {
			return { isSuccess: false, message: 'Entity not found' };
		}

		// Update
		const entity = await db.entity.update({
			where: { id },
			data: input,
		});

		return {
			isSuccess: true,
			message: 'Entity updated successfully',
			data: entity,
		};
	} catch (error) {
		console.error('Error updating entity:', error);
		return { isSuccess: false, message: 'Failed to update entity' };
	}
}

// Delete
export async function deleteEntityAction(
	id: string
): Promise<ActionState<void>> {
	try {
		// Check if entity exists
		const existing = await db.entity.findUnique({ where: { id } });
		if (!existing) {
			return { isSuccess: false, message: 'Entity not found' };
		}

		// Delete
		await db.entity.delete({ where: { id } });

		return {
			isSuccess: true,
			message: 'Entity deleted successfully',
		};
	} catch (error) {
		console.error('Error deleting entity:', error);
		return { isSuccess: false, message: 'Failed to delete entity' };
	}
}
```

## File Organization

### Single Entity Actions File

```typescript
// src/lib/db/entity/entity.actions.ts
import { db } from '@numio/ai-database';
import { ActionState } from '@/types';
import {
	CreateEntityInput,
	UpdateEntityInput,
	GetEntitiesParams,
} from './entity.types';

// CRUD Functions
export async function createEntityAction(
	input: CreateEntityInput
): Promise<ActionState<Entity>> {
	/* ... */
}
export async function getEntityByIdAction(
	id: string
): Promise<ActionState<Entity>> {
	/* ... */
}
export async function getEntitiesAction(
	params: GetEntitiesParams
): Promise<ActionState<Entity[]>> {
	/* ... */
}
export async function updateEntityAction(
	id: string,
	input: UpdateEntityInput
): Promise<ActionState<Entity>> {
	/* ... */
}
export async function deleteEntityAction(
	id: string
): Promise<ActionState<void>> {
	/* ... */
}

// Specialized Functions
export async function getEntityWithRelationsAction(
	id: string
): Promise<ActionState<EntityWithRelations>> {
	/* ... */
}
export async function searchEntitiesAction(
	query: string
): Promise<ActionState<Entity[]>> {
	/* ... */
}
```

## Validation Patterns

### Input Validation Functions

```typescript
export function validateEntityInput(input: CreateEntityInput): {
	isValid: boolean;
	error?: string;
} {
	if (!input.name || input.name.trim().length === 0) {
		return { isValid: false, error: 'Name is required' };
	}

	if (input.name.length > 100) {
		return { isValid: false, error: 'Name too long' };
	}

	return { isValid: true };
}

export function validateUpdateEntityInput(input: UpdateEntityInput): {
	isValid: boolean;
	error?: string;
} {
	if (input.name !== undefined && input.name.trim().length === 0) {
		return { isValid: false, error: 'Name cannot be empty' };
	}

	if (input.name && input.name.length > 100) {
		return { isValid: false, error: 'Name too long' };
	}

	return { isValid: true };
}
```

## Error Handling

### Consistent Error Patterns

```typescript
export async function createUserAction(
	input: CreateUserInput
): Promise<ActionState<User>> {
	try {
		// Validate input
		const validation = validateUserInput(input);
		if (!validation.isValid) {
			return { isSuccess: false, message: validation.error };
		}

		// Check for existing user
		const existingUser = await db.user.findUnique({
			where: { email: input.email },
		});

		if (existingUser) {
			return { isSuccess: false, message: 'User already exists' };
		}

		// Create user
		const user = await db.user.create({ data: input });

		return {
			isSuccess: true,
			message: 'User created successfully',
			data: user,
		};
	} catch (error) {
		console.error('Error creating user:', error);
		return { isSuccess: false, message: 'Failed to create user' };
	}
}
```

## Examples

### ✅ Good Examples

```typescript
// Consistent CRUD pattern
export async function createTeamAction(
	input: CreateTeamInput
): Promise<ActionState<Team>> {
	try {
		const validation = validateTeamInput(input);
		if (!validation.isValid) {
			return { isSuccess: false, message: validation.error };
		}

		const team = await db.team.create({ data: input });
		return {
			isSuccess: true,
			message: 'Team created successfully',
			data: team,
		};
	} catch (error) {
		console.error('Error creating team:', error);
		return { isSuccess: false, message: 'Failed to create team' };
	}
}

// Specialized function
export async function getTeamWithMembersAction(
	teamId: string
): Promise<ActionState<TeamWithMembers>> {
	try {
		const team = await db.team.findUnique({
			where: { id: teamId },
			include: {
				memberships: {
					include: { user: true },
				},
			},
		});

		if (!team) {
			return { isSuccess: false, message: 'Team not found' };
		}

		return { isSuccess: true, data: team };
	} catch (error) {
		console.error('Error fetching team with members:', error);
		return { isSuccess: false, message: 'Failed to fetch team' };
	}
}
```

### ❌ Bad Examples

```typescript
// Class-based approach - DON'T DO THIS
export class TeamActions {
	async create(input: CreateTeamInput) {
		/* ... */
	}
}

// Inconsistent error handling
export async function createUser(input: CreateUserInput) {
	const user = await db.user.create({ data: input });
	return user; // No error handling, no consistent return type
}

// Missing validation
export async function updateTeamAction(id: string, data: any) {
	const team = await db.team.update({ where: { id }, data });
	return { success: true, team }; // Inconsistent return format
}

// No error handling
export async function deleteUserAction(id: string) {
	await db.user.delete({ where: { id } });
	return { success: true }; // No error handling
}
```

## Database Transactions

### Transaction Patterns

```typescript
export async function createTeamWithMembersAction(
	teamData: CreateTeamInput,
	memberIds: string[]
): Promise<ActionState<Team>> {
	try {
		const result = await db.$transaction(async (tx) => {
			// Create team
			const team = await tx.team.create({ data: teamData });

			// Create memberships
			const memberships = await Promise.all(
				memberIds.map((userId) =>
					tx.membership.create({
						data: {
							userId,
							teamId: team.id,
							role: 'MEMBER',
						},
					})
				)
			);

			return { team, memberships };
		});

		return {
			isSuccess: true,
			message: 'Team created with members',
			data: result.team,
		};
	} catch (error) {
		console.error('Error creating team with members:', error);
		return { isSuccess: false, message: 'Failed to create team with members' };
	}
}
```

## Logging and Monitoring

### Action Logging

```typescript
export async function createUserAction(
	input: CreateUserInput
): Promise<ActionState<User>> {
	const startTime = Date.now();

	try {
		console.log('Creating user:', { email: input.email, name: input.name });

		const user = await db.user.create({ data: input });

		console.log('User created successfully:', {
			userId: user.id,
			duration: Date.now() - startTime,
		});

		return {
			isSuccess: true,
			message: 'User created successfully',
			data: user,
		};
	} catch (error) {
		console.error('Error creating user:', {
			error,
			duration: Date.now() - startTime,
		});
		return { isSuccess: false, message: 'Failed to create user' };
	}
}
```

## Testing

### Action Testing

```typescript
describe('createUserAction', () => {
	it('should create user successfully', async () => {
		const input = { name: 'Test User', email: 'test@example.com' };

		const result = await createUserAction(input);

		expect(result.isSuccess).toBe(true);
		expect(result.data).toMatchObject(input);
	});

	it('should return error for invalid input', async () => {
		const input = { name: '', email: 'invalid-email' };

		const result = await createUserAction(input);

		expect(result.isSuccess).toBe(false);
		expect(result.message).toContain('required');
	});
});
```

## Key Rules

1. **NO CLASSES** - Use functions only
2. **CRUD Pattern** - create, read, update, delete functions
3. **Consistent Return** - Always return ActionState<T>
4. **Validation** - Validate inputs before database operations
5. **Error Handling** - Try-catch with proper error logging
6. **Naming** - Use Action suffix for all functions
7. **Grouping** - Keep related actions in single files
8. **Types** - Use proper TypeScript types for inputs and outputs

description: Follow consistent CRUD patterns for server actions using functions only
globs:

- src/lib/db/_/_.actions.ts
  alwaysApply: true
