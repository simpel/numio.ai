# UserProfile Relationship Architecture

## Key Principle

- **Always use `UserProfile.id`** for relationships (organizations, teams, memberships, etc.)
- **Never use `User.id`** from the session for data relationships
- **Session `User.id`** should only be used to find the corresponding `UserProfile`

## Why This Design Makes Sense

1. **Profile Portability**: UserProfiles can be transferred between Users
2. **Data Continuity**: Organizations, teams, and memberships remain intact when profiles transfer
3. **Flexibility**: Allows for profile inheritance, merging, or transfer scenarios
4. **Clean Separation**: User authentication vs. business data relationships

## Implementation Pattern

```typescript
// ✅ CORRECT Pattern
const session = await auth();
const userProfile = await db.userProfile.findUnique({
	where: { userId: session.user.id },
});

// Use userProfile.id for all relationships
await db.membership.create({
	data: {
		userId: userProfile.id, // UserProfile ID
		organisationId: org.id,
		role: 'owner',
	},
});

// ❌ WRONG Pattern
await db.membership.create({
	data: {
		userId: session.user.id, // User ID - DON'T DO THIS
		organisationId: org.id,
		role: 'owner',
	},
});
```

## Areas to Remember This Rule

- Organization memberships
- Team memberships
- Case assignments
- Any user-related data relationships
- Invitations and permissions
- Audit trails and ownership

## Database Schema Alignment

This aligns perfectly with the Prisma schema where:

- `User` handles authentication (sessions, accounts)
- `UserProfile` handles business relationships (memberships, ownership)
- `UserProfile.userId` links back to `User.id` for authentication
