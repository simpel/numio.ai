---
description:
globs:
  - src/**/*.{ts,tsx}
alwaysApply: true
---

1. Fetch Data on the Server by Default
   1. Use Server Components.  
      • In a Server Component:

   ```ts
   import { prisma } from '@/lib/db';
   const chats = await db.chat.findMany();
   ```

   • Pass `chats` down as props to Client Components—no SWR import needed.  
   2. Never call `useSWR` in a Server Component or at build time. SWR is client-only and for runtime needs.

2. Use SWR Only for Client-Runtime Fetches
   1. Expose all read operations via idempotent GET endpoints in `app/api/.../route.ts`.
   2. In Client Components, use:

   ```ts
   'use client';
   import useSWR from 'swr';

   const fetcher = (url: string) => fetch(url).then((res) => res.json());

   const { data } = useSWR(['chatSettings', chatId], fetcher);
   ```

• Stable key arrays dedupe and share cache. 3. Mutations via Server Actions 5. Define all mutations with "use server" in /src/lib/db/<model>/<model>.actions.ts. 6. From a Client Component, invoke:

'use client'
import { addTodo } from '@/lib/db/todo/todo.actions'
// …
await addTodo(data)

• No custom POST routes—Next.js serializes these calls.

    4.	Cache Invalidation & Revalidation

7. After a mutation, always call mutate(key) in the client to refresh SWR.
8. For server-side cache, use revalidatePath('/api/...') or revalidateTag('todos') inside your Server Action.
9. Configure SWR’s revalidateOnFocus, revalidateOnReconnect, or refreshInterval per use-case. 5. Keying & Fetcher Patterns
10. Include dynamic IDs in your cache key arrays (e.g. ['chatSettings', chatId]).
11. Fetchers should map one-to-one with their keys and return only the requested resource. 6. Security & Performance
12. Enforce CSRF protection: set serverActions.allowedOrigins in next.config.js as needed.
13. Rely on SWR’s built-in deduplication to skip redundant requests.
14. For high-frequency polling, use SWR’s refreshInterval—keep heavy polling client-side.
